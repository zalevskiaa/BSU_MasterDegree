### 01-A Длиннейшая чередующаяся подпоследовательность

Найдите наибольшую чередующуюся подпоследовательность ai1,ai2,…,aik
последовательности a1,a2,…,an
, то есть такую подпоследовательность, для которой i1<i2<…<ik
, любые два соседних элемента различны, и для любых трех соседних элементов ail−1,ail,ail+1
либо ail−1<ail,ail>ail+1
, либо ail−1>ail,ail<ail+1
, при этом k
~--- наибольшее возможное.

### 01-B Правильная скобочная последовательность

Правильной скобочной последовательностью} называется строка, состоящая только из скобок, в которой все скобки можно разбить на пары таким образом, что:

в каждой паре есть левая и правая скобка, причем левая скобка расположена левее правой;
для любых двух пар скобок либо одна из них полностью внутри другой пары, либо промежутки между скобками в парах не пересекаются
в паре с круглой скобкой может быть только круглая скобка, с квадратной~--- квадратная, с фигурной -- фигурная
Примеры: * Если разрешены только круглые скобки:

правильные последовательности: (), (()), ()(), ()()(), (())(), ((()))

неправильные последовательности: {)(, )), ((, ())()(, ()), ))((

Если разрешены круглые и квадратные скобки:

правильные последовательности: [],(), [()], [[([])]()]
неправильные последовательности: [), ([)], (())()[]][
Если разрешены еще и фигурные скобки:

правильные последовательности: [{(())}({})], []{}(), {}, (), []

неправильные последовательности: [{(})], [(]())]{}

### 01-E Максимум в скользящем окне

Пусть задан массив из n
целых чисел. По этому массиву будут ходить два указателя l
и r
(1≤l,r≤n
). Изначально оба они указывают на первый элемент массива (l=r=1
). Оба указателя могут двигаться только вправо, на одну позицию за раз. При этом указатель l
никогда не оказывается правее указателя r
, и ни один из них не выходит за пределы массива.

Вам нужно после каждого перемещения указателя определить максимум всех элементов от указателя l
вправо до указателя r
(включая позиции, на которые указывают l
и r
).

Указание. Учетная стоимость обработки каждого запроса на перемещение и подсчет максимума должна оказаться O(1)
.

### 02-A Три последовательности


| Ограничение времени | 2 секунды                        |
|---------------------|----------------------------------|
| Ограничение памяти  | 256Mb                            |     
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |

Даны три последовательности целых чисел. Ваша задача — найти их наибольшую общую подпоследовательность.

Формат ввода

Входной файл содержит описание трех последовательностей. Каждая последовательность задается двумя строчками. Первая строка содержит длину последовательности n (1 ≤ n ≤ 100), а вторая — ее элементы (32-х битные целые числа).

Формат вывода

Первая строка выходного файла должна содержать длину максимальной общей подпоследовательности. Саму подпоследовательность необходимо вывести во второй строке. Если таких строк несколько, можно вывести любую из них.

Пример

Ввод

3  
1 2 3  
3  
2 1 3  
3  
1 3 5  

Вывод

2
1 3

### 02-B Футбольная команда

| Ограничение времени | 0.5 секунд                       |
|---------------------|----------------------------------|
| Ограничение памяти  | 64Mb                             |     
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |

Тип задачи: практическая, с код-ревью.

Вы хотите набрать футбольную команду. 
У каждого игрока своя эффективность, она описывается одним целым числом. 
Чем больше число, тем больше эффективность футболиста. 
Обязательным условием для любой команды является сплоченность. 
Если один из игроков играет сильно лучше всех остальных, его будут недолюбливать, и команда распадется. 
Поэтому эффективность любого игрока команды не должна превышать сумму эффективностей любых двух других игроков. 
Ваша задача — набрать команду, которая будет удовлетворять условию сплоченности, и при этом иметь наибольшую суммарную эффективность.

Формат ввода

В первой строке входа задано число n (1 ≤ n ≤ 100000). 
Во второй строке — эффективности каждого из n игроков — положительные целые числа, не превосходящие 231 - 1.

Формат вывода

Выведите две строки. В первую запишите наибольшую возможную сумму эффективностей игроков в команде. Во вторую строку выведите номера всех игроков, которых нужно взять в команду, в порядке возрастания.

Пример 1

Ввод	

5  
3 2 5 4 1  

Вывод

14  
1 2 3 4  

Пример 2

Ввод	

5
1 2 4 8 16

Вывод

24
4 5

Примечания

Игроки пронумерованы от 1 до n в том порядке, в котором заданы их эффективности на входе. Если существует несколько способов набрать команду максимальной эффективности, выведите любой из них.

### 02-C Слияние отсортированных последовательностей


| Ограничение времени | 1 секунда                        |
|---------------------|----------------------------------|
| Ограничение памяти  | 64Mb                             |     
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |

Вам дано n упорядоченных по возрастанию последовательностей целых чисел, каждая из которых имеет длину m. 
Необходимо слить их в одну упорядоченную по возрастанию последовательность целых чисел длины mn. 
Сложность алгоритма не должна превышать O(mn log n), затраты памяти — O(mn).

Формат ввода

В первой строке входа два целых числа n, m (1 ≤ m, n ≤ 1000). В следующих n строках по m целых чисел в каждой, числа в каждой строке упорядочены по возрастанию. Числа не превосходят по модулю 109.

Формат вывода

Выведите все mn чисел, упорядоченных по возрастанию.

Пример 1  
Ввод  
2 5  
1 3 5 7 9  
2 4 6 8 10  
Вывод  
1 2 3 4 5 6 7 8 9 10  

Пример 2  
Ввод  
4 2  
1 4  
2 8  
3 7  
5 6  
Вывод  
1 2 3 4 5 6 7 8


### 02-D Одномерный почтальон


| Ограничение времени | 1 секунда                        |
|---------------------|----------------------------------|
| Ограничение памяти  | 256Mb                            |     
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |

В деревне Печалька живут n человек, их домики расположены ровно на оси абсцисс. 
Домик i-го человека находится в точке `x_i`.
В деревню приехал и хочет там поселиться почтальон. 
Координату своего домика y он хочет выбрать так, 
чтобы суммарное расстояние от него до всех жителей деревни было минимально возможным.   
То есть `sum(abs(y - x_i) for i in range(1, n + 1))` `-> min`

Вам дан массив x из n случайных целых чисел. 
Найдите точку y.

Формат ввода

На первой строке число n (1 ≤ n ≤ 10^7). 
На второй строке пара целых чисел a, b от 1 до 10^9, 
используемая в генераторе случайных чисел.

```
unsigned int cur = 0; // беззнаковое 32-битное число  
unsigned int nextRand24() {  
cur = cur * a + b; // вычисляется с переполнениями  
return cur >> 8; // число от 0 до 2**24-1.  
}  
unsigned int nextRand32() {  
unsigned int a = nextRand24(), b = nextRand24();  
return (a << 8) ̂ b; // число от 0 до 2**32-1.  
}
```
Элементы массива генерируются последовательно. xi = nextRand32();

Формат вывода

Выведите одно число — минимальное суммарное расстояние от точки y до всех домиков.

### 03-A Fixed set

Реализуйте cледующий класс для хранения множества целых чисел:

```
class FixedSet {
public:
FixedSet();
void Initialize(const vector<int>& numbers);
bool Contains(int number) const;
};
```
При вызове Initialize FixedSet получает набор целых чисел, 
который впоследствии и будет хранить. 
Набор чисел не будет изменяться с течением времени 
(до следующего вызова Initialize). 
Операция Contains возвращает true, если число number содержится в наборе. 
Мат. ожидание времени работы Initialize должно составлять O(n), 
где n --- количество чисел в numbers. 
Затраты памяти должны быть порядка O(n) в худшем случае. 
Операция Contains должна выполняться за O(1) в худшем случае.

С помощью этого класса решите модельную задачу: на вход будет дано множество различных чисел, а затем множество запросов --- целых чисел. Необходимо для каждого запроса определить, лежит ли число из запроса в множестве.

### 03-C Менеджер памяти

Пете поручили написать менеджер памяти для новой стандартной библиотеки языка H++.

В распоряжении у менеджера находится массив из N
последовательных ячеек памяти, пронумерованных от 1
до N
. Задача менеджера --- обрабатывать запросы приложений на выделение и освобождение памяти.

Запрос на выделение памяти имеет один параметр K
. Такой запрос означает, что приложение просит выделить ему K
последовательных ячеек памяти. Если в распоряжении менеджера есть хотя бы один свободный блок из K
последовательных ячеек, то он обязан в ответ на запрос выделить такой блок. При этом наш менеджер выделяет память из самого длинного свободного блока, а если таких несколько, то из них он выбирает тот, у которого номер первой ячейки --- наименьший. После этого выделенные ячейки становятся занятыми и не могут быть использованы для выделения памяти, пока не будут освобождены. Если блока из K
последовательных свободных ячеек нет, то запрос отклоняется.

Запрос на освобождение памяти имеет один параметр T
. Такой запрос означает, что менеджер должен освободить память, выделенную ранее при обработке запроса с порядковым номером T
. Запросы нумеруются, начиная с единицы. Гарантируется, что запрос с номером T
--- запрос на выделение, причем к нему еще не применялось освобождение памяти. Освобожденные ячейки могут снова быть использованы для выделения памяти. Если запрос с номером T
был отклонен, то текущий запрос на освобождение памяти игнорируется.

Требуется написать симуляцию менеджера памяти, удовлетворяющую приведенным критериям.

### 04-A Количество деревьев поиска


| Ограничение времени | 1.5 секунды                      |
|---------------------|----------------------------------|
| Ограничение памяти  | 64Mb                             |     
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |

Посчитайте количество различных бинарных деревьев поиска, 
состоящих из n вершин с ключами a_1, a_2, …, a_n. 
Рассматриваются только такие деревья поиска, 
у которых в левом поддереве ключи строго меньше, 
а в правом — не меньше, чем в корне.
Когда два дерева считаются одинаковыми — интуитивно понятно: 
если нарисовать их на картинке, то картинки должны выглядеть одинаково. 
Формально это можно определить, например, так: два дерева считаются одинаковыми, 
если их preorder обходы порождают одну и ту же последовательность чисел.
Ответ может быть очень большим числом, поэтому посчитайте его по модулю 123456789.
Значения ключей от −2^31 до 2^31−1.

Формат ввода

В первой строке входа число n ( 1 ≤ n ≤ 4 0 0 ). 
Во второй строке — n целых чисел a 1 , a 2 , … , a n .

Пример 1  
Ввод  
2  
2 1  
Вывод  
2  

Пример 2  
Ввод  
3  
10 10 10  
Вывод  
1  

Пример 3  
Ввод  
3  
1 2 3  
Вывод  
5  


### 05-B Почтовый робот


| Ограничение времени | 2 секунды                        |
|---------------------|----------------------------------|
| Ограничение памяти  | 512Mb                            |     
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |

В стране X случилась беда. Сломался почтовый робот, который занимался доставкой почты в самые разные уголки X. Страну X можно представить как поле размера N × M, каждая клетка которого либо проходима, либо нет. Раньше, когда роботу нужно было добраться из пункта A в пункт B, он вычислял кратчайший путь по свободным клеткам и добирался до пункта назначения, либо (если получатель жил где-нибудь в болотах) сообщал, что доставить почту невозможно.

Из текущей клетки робот может переместиться только в соседние с ней по стороне. При этом роботу также нужно совершать повороты, т.е. если, например, робот шел вправо, а ему нужно переместиться вверх, он сначала совершает поворот налево. Аналогично, он может поворачиваться направо. Разработчики робота также предусмотрели поворот в противоположную текущему направлению сторону, т.е. вокруг себя. Но повороты не учитывались при вычислении кратчайшего пути, поскольку роботу легко их выполнять.

В результате сбоя робот после совершения поворота налево не может далее поворачиваться налево до тех пор, пока не сделает поворот направо, и наоборот. Повороты вокруг себя совершаются независимо и не влияют на это правило, однако робот не может совершать более одного поворота, находясь в одной клетке. Вам поручили написать модифицированную программу для робота, чтобы он мог вычислять кратчайшие пути с этим сбоем.


Формат ввода

В первой строке входного файла записано 2 целых числа через пробел — N и M (1 ≤ N, M ≤ 1000). Далее следует описание поля — N строк по M символов в каждой. Символ '.' означает, что эта клетка свободна, а '#' — что через нее пройти нельзя. В следующей строке записано 2 целых числа через пробел — r1 и c1 (1 ≤ r1 ≤ n и 1 ≤ c1 ≤ m) — начальная позиция робота (сначала номер строки, а потом номер столбца). Наконец, в последней строке записаны координаты пункта назначения в том же формате.

Изначально до совершения первого шага робота можно повернуть в любую сторону. Гарантируется, что начальная и конечная клетки свободны.

Формат вывода

Если искомого пути не существует, выведите число -1. В противном случае выведите в первой строке число K — количество шагов в кратчайшем пути. Далее должно следовать K + 1 строка, описывающие маршрут робота (клетки, по которым ему нужно пройти). При этом первая клетка в маршруте должна совпадать со стартовой позицией, а последняя — c конечной.

Пример 1  
Ввод
```
5 5
#...#
..#.#
..#.#
..#.#
#....
2 2
2 4
```
Вывод
```
10
2 2
3 2
4 2
5 2
5 3
5 4
5 5
5 4
4 4
3 4
2 4
```
Пример 2  
Ввод
```
4 4
....
###.
....
####
1 1
3 1
```
Вывод
```
-1
```

### 05-C Минимальная стоимость дороги


| Ограничение времени | 0.5 секунды                      |
|---------------------|----------------------------------|
| Ограничение памяти  | 64Mb                             |     
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |


Хонти хочет начать войну против Пандеи. План Хонти состоит в том, чтобы используя эффект неожиданности навести ужас на пандейцев, создать хаос, и в этих условиях быстро завоевать страну. Чтобы успешно воплотить этот план в жизнь, хонтийцам необходимо провести первую, самую важную операцию.

Цель операции — разделить Пандею на две несвязанные части, разрушив всего лишь одну дорогу (изначально карта Пандеи представляет собой связный граф). Хонтийская разведка уже добыла карты Пандеи, передала их экспертам, которые провели исследование и выяснили стоимость разрушения каждой из дорог страны-противника. Вам передали карту всех дорог вместе со стоимостями их разрушения. Вам нужно выбрать самую дешевую дорогу, удовлетворяющую запросам хонтийцев: предстоящая война еще потребует значительных ресурсов.

Формат ввода

В первой строке входа заданы два целых числа n и m — количество городов и количество дорог Пандеи соответственно. Дороги в Пандее двусторонние. В каждой из следующих m строк — по три числа a, b и c — номера начального и конечного городов дороги (города нумеруются с единицы) и стоимость разрушения данной дороги. 1 ≤ m, n ≤ 50  000. 1 ≤ a, b ≤ n. . 1 ≤ c ≤ 1  000  000  000. Для любых двух городов a и b существует не более одной дороги между ними.

Формат вывода

Выведите единственное число — наименьшую стоимость дороги, которую можно разрушить, чтобы нарушить связность Пандеи. Если таких дорог не существует, выведите -1.

Пример 1  
Ввод
```
7 8
1 2 1
2 3 2
3 4 3
4 1 4
3 5 5
5 6 6
6 7 7
7 5 8
```
Вывод
```
5
```
Пример 2  
Ввод
```
7 6
1 2 1
1 3 2
2 4 3
2 5 4
3 6 5
3 7 6
```
Вывод
```
1
```
Пример 3  
Ввод
```
2 1
1 2 10
```
Вывод
```
10
```
Пример 4  
Ввод	
```
6 7
1 2 1
2 3 2
3 1 3
2 4 4
4 5 5
5 6 6
6 2 7
```
Вывод
```
-1
```
### 06-D Магия


| Ограничение времени | 1 секунда                        |
|---------------------|----------------------------------|
| Ограничение памяти  | 64Mb                             |     
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |

Сказочная страна представляет собой множество городов, соединенных дорогами с двухсторонним движением. Причем из любого города страны можно добраться в любой другой город либо непосредственно, либо через другие города. Известно, что в сказочной стране не существует дорог, соединяющих город сам с собой и между любыми двумя разными городами, существует не более одной дороги.

В сказочной стране живут желтый и синий волшебники. Желтый волшебник, пройдя по дороге, перекрашивает ее в желтый цвет, синий — в синий. Как известно, при наложении желтой краски на синюю, либо синей краски на желтую, краски смешиваются и превращаются в краску зеленого цвета, который является самым нелюбимым цветом обоих волшебников.

В этом году в столице страны (городе f) проводится конференция волшебников. Желтый и синий волшебники хотят узнать, какое минимальное количество дорог им придется перекрасить в зеленый цвет, чтобы добраться в столицу. Изначально все дороги не покрашены.

Начальное положение желтого и синего волшебников заранее не известно. Поэтому необходимо решить данную задачу для k возможных случаев их начальных расположений.

Формат ввода

Первая строка входного файла содержит целые числа: n (1 ≤ n ≤ 100 000) и m (1 ≤ m ≤ 500 000) — количество городов и дорог в волшебной стране соответственно. Третья строка содержит одно целое число f (1 ≤ f ≤ n) — номер города, являющегося столицей сказочной страны. В следующих m строках, находится описание дорог страны. В этих m строк записано по два целых числа ai и bi, означающих, что существует дорога, соединяющая города ai и bi. Следующая строка содержит целое число k (1 ≤ k ≤ 100 000) — количество возможных начальных расположений волшебников. Далее следуют k строк, каждая из которых содержит два целых числа — номера городов, в которых изначально находится желтый и синий волшебники соответственно.

Формат вывода

Для каждого из k случаев, ваша программа должна вывести в выходной минимальное количество дорог, которое придется покрасить в зеленый цвет волшебникам для того, чтобы добраться в столицу.

Пример  
Ввод
```
6 6
1
1 2
2 3
3 4
4 2
4 5
3 6
2
5 6
6 6
```
Вывод
```
1
2
```

### 06-E Длина объединения отрезков


| Ограничение времени | 2 секунды                        |
|---------------------|----------------------------------|
| Ограничение памяти  | 64Mb                             |     
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |

Рассмотрим множество отрезков на прямой с целыми концами. Изначально множество пустое, в него могут добавляться отрезки, из него могут удаляться отрезки. После каждой операции вставки или удаления отрезка необходимо вывести общую длину объединения всех отрезков, лежащих на данный момент в множестве.

Формат ввода

В первой строке входа записано целое число 1 <= n <= 100  000 — общее количество проделанных операций. Далее идут n строк, каждая из них устроена следующим образом. Первый символ — “+”, если это операция вставки отрезка и “-”, если это операция удаления отрезка. Далее в строке записаны через пробел два целых числа — левый и правый концы отрезка. Координаты концов по модулю не превосходят 1  000  000  000. Гарантируется, что удаляться будут только отрезки, которые перед этим были добавлены в множество.

Формат вывода

Выведите ровно n чисел, по одному в строке — общую длину объединения всех отрезков в множестве после каждой из n операций добавления/удаления.

Пример
Ввод	
```
4
+ 1 3
+ 2 6
+ 5 7
- 2 6
```
Вывод
```
2
5
6
4
```